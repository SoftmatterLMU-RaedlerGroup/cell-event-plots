%plotCorrelation_histograms plots histograms of event times for the different markers.
%
% Required variables in workspace:
%	corrT			table of marker combinations,
%					as generated by loadCorrelationData
%	fileT			table of available files,
%					as generated by loadCorrelationData
%	out_dir			directory to write output files
%					(optional; file export only if present)
%
% Workspace variables generated by this script:
%	aha				array of axes handles of the generated histograms
%	markerData		table of analyzed markers, with variables:
%		.shortName		short marker name (abbreviation for internal use)
%		.displayName	long marker name (used for figure labels)
%		.color			color to be used for this marker’s histogram
%		.groups			struct of grouped data, with fields:
%			.name			same as `markerData.shortName
%			.files			array of keys of files in `fileT`
%			.times			array of finite (“good”) event times
%			.bad			number of non-finite(“bad”) event times
%			.t_max			time of fit maximum for this group
%			.color			color to be used for this group’s histogram (*)
%			.legend_index	index of corresponding row in legend table (*)
%	lgdT			table with legend information; indexed by the
%					`legend_index` field. This variable is only present if
%					the `legend_index` field is specified.
%
% (*) If the `color` field is specified, the color specified in the legend
%     table is ignored and both the `legend_index` and `lgdT` may be
%     omitted. Else, the `legend_index` field is required.
%
% Copyright © 2018 Daniel Woschée <daniel.woschee@physik.lmu.de>
% Faculty of Physics / Ludwig-Maximilians-Universität München
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License version 2
% as published by the Free Software Foundation.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program. If not, see <https://www.gnu.org/licenses/>.

%% Define Parameters
markerData = table(string.empty, string.empty, zeros(0,3), cell(0), ...
	'VariableNames', {'shortName', 'displayName', 'color', 'groups'});
markerData(end+1,:) = table("lyso", "LysoTracker", [0 0.8 0], {struct});
markerData(end+1,:) = table("tmrm", "TMRM", [1 1 0], {struct});
markerData(end+1,:) = table("ros", "CellRox", [0.8 1 0], {struct});
markerData(end+1,:) = table("casp", "Caspase 3/7", [1 0.6 0], {struct});
markerData(end+1,:) = table("psiva", "pSIVA-IANBD", [1 0 0], {struct});
markerData(end+1,:) = table("pi", "Nucleus (PI)", [0.4 0 0], {struct});
markerData(end+1,:) = table("toto", "Nucleus (toto)", [0.4 0 0], {struct});
markerData(end+1,:) = table("cal520", "Calbryte 520", [0 0.5 0.8], {struct});

n_bins = 40;					% Number of bins in histogram plots
event_time_max = 30;			% Default maximum time bin [h]

y_label_hist = 'Cell count';	% Label of y-axis in histogram plots
x_label_hist = 'Time [h]';		% Label of x-axis in histogram plots

cmpOpt_none = 'None';			% Histogram grouping option: no grouping
cmpOpt_comb = 'Combinations';	% Histogram grouping option: by combinations
cmpOpt_meas = 'Measurements';	% Histogram grouping option: by measurements
cmpOpt_exp = 'Experiments';		% Histogram grouping option: by experiment
								% (= by measurements and combinations)

text_arrow = char(8594);		% Unicode arrow character

% Define white list of conditions to be used
if ~exist('restrict_to_conditions', 'var')
	restrict_to_conditions = {};
end

% Define whether to normalize histograms
if ~exist('doNormalize', 'var')
	doNormalize = true;
end

% Define whether to filter out cells
if ~exist('evtFilter', 'var')
	evtFilter = '*';
end

%% Ask user which data to use for histogram
% Get all available measurements in selected combinations
file_idcs = [];
for iMap = 1:numel(corrT.file_map)
	file_idcs = [ file_idcs; corrT.file_map{iMap}(:,1) ];
end
measurements = unique(fileT.measurement(ismember(fileT.index_f, file_idcs)));

% Prompt user to select measurements
[meas_sel, isOK] = listdlg( ...
	'PromptString', 'Select the measurements to plot:', ...
	'Name', 'Measurement selection', ...
	'ListString', { measurements{:} }, ...
	'SelectionMode', 'multiple', ...
	'InitialValue', 1:numel(measurements));
if ~isOK || (length(meas_sel) == 1 && meas_sel == 0)
	return
end
measurements = measurements(meas_sel);

%% Find markers missing in `markerData` and add them
mkrMissing = corrT.markers(~ismember(corrT.markers, markerData.shortName));
mkrMissing = unique(mkrMissing);
if isempty(mkrMissing)
	mkrMissing = [];
elseif ~isrow(mkrMissing)
	mkrMissing = mkrMissing.';
end

for marker = mkrMissing
	iRow = height(markerData) + 1;
	markerData(iRow,:) = table(string(marker), string(marker), ...
		[ .75, .75, .75 ], {struct});
	warning('Encountered undefined marker: %s', marker);
end

%% Ask user whether to compare different measurements of combinations
[cmpOpt, doNormalize, evtFilter, isFrcYlim] = ...
	getPlotOpt({cmpOpt_none cmpOpt_comb cmpOpt_meas cmpOpt_exp}, ...
	doNormalize, evtFilter);
if isempty(cmpOpt)
	disp('No comparison setting given; quit.')
	return
end

%% Build histogram groups
lgdT = table(string.empty(0,1), NaN(0,3), ...
	'VariableNames', {'name', 'color'});
switch cmpOpt
	case cmpOpt_none
		% No histogram grouping – plot all data in one histogram
		% Perpare struct with default fields for each marker
		for iMkr = 1:height(markerData)

			% Get files of this marker
			idxCorr = ismember(corrT.markers, markerData.shortName{iMkr});
			if any(idxCorr(:))
				idxFile = vertcat(corrT.file_map{idxCorr});
				idxFile = idxFile(:,1);

				% Prepare groups structure for this marker
				markerData.groups{iMkr}.name = '';
				markerData.groups{iMkr}.files = idxFile;
				markerData.groups{iMkr}.times = [];
				markerData.groups{iMkr}.bothEvents = 0;
				markerData.groups{iMkr}.firstEvent = 0;
				markerData.groups{iMkr}.secondEvent = 0;
				markerData.groups{iMkr}.noEvent = 0;
				markerData.groups{iMkr}.t_max = NaN;
				markerData.groups{iMkr}.uncert_tmax = NaN;
				markerData.groups{iMkr}.mu = NaN;
				markerData.groups{iMkr}.sigma = NaN;
				markerData.groups{iMkr}.color = markerData.color(iMkr,:);
			else
				% Set groups structure for this marker to empty structure
				markerData.groups{iMkr} = [];
			end
		end

	case cmpOpt_meas
		% Group histogram data per measurement/date
		% Prepare one group per measurement
		measurementsUsed = [];
		for iMkr = 1:height(markerData)
			% Get files of this measurement
			idxCorr = find(corrT.markers == markerData.shortName{iMkr});
			if ~isempty(idxCorr)
				idxFile = vertcat(corrT.file_map{idxCorr});
				idxFile = idxFile(:,1);
			else
				idxFile = [];
			end

			iGrp = 0;
			for iMeas = 1:numel(measurements)
				thisIdx = ismember(fileT.measurement, measurements(iMeas)) & ...
					ismember(fileT.index_f, idxFile);
				thisIdx = fileT.index_f(thisIdx);
				if ~isempty(thisIdx)
					iGrp = iGrp + 1;
					thisName = measurements(iMeas);

					% Find or create corresponding entry in legend table
					lgdIdx = find(strcmpi(lgdT.name, thisName), 1);
					if isempty(lgdIdx)
						lgdIdx = height(lgdT) + 1;
						lgdT(lgdIdx,:) = {thisName, NaN};
					end

					% Write group to `markerData`
					markerData.groups{iMkr}(iGrp).name = thisName;
					markerData.groups{iMkr}(iGrp).files = thisIdx;
					markerData.groups{iMkr}(iGrp).times = [];
					markerData.groups{iMkr}(iGrp).bothEvents = 0;
					markerData.groups{iMkr}(iGrp).firstEvent = 0;
					markerData.groups{iMkr}(iGrp).secondEvent = 0;
					markerData.groups{iMkr}(iGrp).noEvent = 0;
					markerData.groups{iMkr}(iGrp).t_max = NaN;
					markerData.groups{iMkr}(iGrp).uncert_tmax = NaN;
					markerData.groups{iMkr}(iGrp).mu = NaN;
					markerData.groups{iMkr}(iGrp).sigma = NaN;
					markerData.groups{iMkr}(iGrp).legend_index = lgdIdx;
				end
			end

			if iGrp == 0
				% Set empty value
				markerData.groups{iMkr} = [];
			end
		end

	case cmpOpt_comb
		% Group histogram data per marker combination
		% Prepare one group per marker combination
		for iMkr = 1:height(markerData)
			iGrp = 0;

			for iCmb = 1:height(corrT)
				% Find combinations with this marker
				jMkr = ismember(corrT.markers(iCmb,:), markerData.shortName(iMkr));
				if any(jMkr)
					iGrp = iGrp + 1;
				else
					continue
				end
				thisName = sprintf("%s %s %s", corrT.markers(iCmb,1), ...
					text_arrow, corrT.markers(iCmb,2));

				% Find or create entry in legend table
				lgdIdx = find(strcmpi(lgdT.name, thisName), 1);
				if isempty(lgdIdx)
					lgdIdx = height(lgdT) + 1;
					lgdT(lgdIdx,:) = {thisName, corrT.color(iCmb,:)};
				end

				% Prepare group
				markerData.groups{iMkr}(iGrp).name = thisName;
				markerData.groups{iMkr}(iGrp).files = corrT.file_map{iCmb,jMkr}(:,1);
				markerData.groups{iMkr}(iGrp).times = [];
				markerData.groups{iMkr}(iGrp).bothEvents = 0;
				markerData.groups{iMkr}(iGrp).firstEvent = 0;
				markerData.groups{iMkr}(iGrp).secondEvent = 0;
				markerData.groups{iMkr}(iGrp).noEvent = 0;
				markerData.groups{iMkr}(iGrp).t_max = NaN;
				markerData.groups{iMkr}(iGrp).uncert_tmax = NaN;
				markerData.groups{iMkr}(iGrp).mu = NaN;
				markerData.groups{iMkr}(iGrp).sigma = NaN;
				markerData.groups{iMkr}(iGrp).legend_index = lgdIdx;
			end

			if iGrp == 0
				% Set empty value
				markerData.groups{iMkr} = [];
			end
		end

	case cmpOpt_exp
		% Group histogram data per experiment (= combination/measurement)

		for iMkr = 1:height(markerData)
			iGrp = 0;

			for iCmb = 1:height(corrT)
				% Get files of this combination
				idxCorr = ismember(corrT.markers(iCmb,:), markerData.shortName(iMkr));
				if any(idxCorr)
					idxFile = corrT.file_map{iCmb,idxCorr}(:,1);
				else
					% No files found for this combination
					continue
				end

				% Get measurements comprising this combination
				thisFileT = fileT(ismember(fileT.index_f, idxFile),:);
				measurementsUsed = unique(thisFileT.measurement);

				% Create group for histogram
				for iMeas = 1:length(measurementsUsed)
					iGrp = iGrp + 1;
					thisMeas = measurementsUsed{iMeas};
					thisName = sprintf('%s %s %s (%s)', ...
						corrT.markers(iCmb,1), ...
						text_arrow, ...
						corrT.markers(iCmb,2), ...
						thisMeas);

					% Add this experiment to experiment table
					lgdIdx = find(strcmpi(lgdT.name, thisName), 1);
					if isempty(lgdIdx)
						lgdIdx = height(lgdT) + 1;
						lgdT(lgdIdx,:) = {thisName, NaN};
					end

					% Prepare group
					markerData.groups{iMkr}(iGrp).name = thisName;
					markerData.groups{iMkr}(iGrp).files = ...
						thisFileT.index_f( ...
						strcmpi(thisFileT.measurement, thisMeas));
					markerData.groups{iMkr}(iGrp).times = [];
					markerData.groups{iMkr}(iGrp).bothEvents = 0;
					markerData.groups{iMkr}(iGrp).firstEvent = 0;
					markerData.groups{iMkr}(iGrp).secondEvent = 0;
					markerData.groups{iMkr}(iGrp).noEvent = 0;
					markerData.groups{iMkr}(iGrp).t_max = NaN;
					markerData.groups{iMkr}(iGrp).uncert_tmax = NaN;
					markerData.groups{iMkr}(iGrp).mu = NaN;
					markerData.groups{iMkr}(iGrp).sigma = NaN;
					markerData.groups{iMkr}(iGrp).legend_index = lgdIdx;
				end
			end

			if iGrp == 0
				% Set empty value
				markerData.groups{iMkr} = [];
			end
		end

	otherwise
		error('Undefined histogram grouping option: %s', cmpOpt);
end

% Remove rows from `markerData` table that have no values
markerData(cellfun(@isempty, markerData.groups),:) = [];

% Set up legend table
if ~isempty(lgdT)
	idxNoColor = any(isnan(lgdT.color), 2);
	lgdT.color(idxNoColor,:) = jet(sum(idxNoColor));
	lgdT = [lgdT table(repmat(matlab.graphics.GraphicsPlaceholder, ...
		height(lgdT),1), 'VariableNames', {'sample'})];
end

%% Select traces to plot
idxConditions = uint32.empty;

for iRow = 1:height(corrT)
	for iMkr = 1:size(corrT.markers, 2)

		% Get row number of marker data table
		marker = corrT.markers{iRow, iMkr};
		tRow = find(ismember(markerData.shortName, marker));

		% Continue if marker not requested
		if isempty(tRow)
			continue
		end

		% Find traces of selected measurements
		for iGrp = 1:numel(markerData.groups{tRow})
			fm = corrT.file_map{iRow,iMkr};

			% Get files to use (not from excluded measurement)
			idxM = ismember(fm(:,1), markerData.groups{tRow}(iGrp).files);
			idxF = ismember(fileT.index_f, fm(idxM,1));
			idxM(idxM) = ismember(fileT.measurement(idxF), measurements);
			fm = fm(idxM,:);
			idxConditions = [ idxConditions; fm(:,1) ];

			% Get traces to use (from files to use)
			idxTr = [];
			for fRow = 1:size(fm, 1)
				idxTr = [ idxTr (fm(fRow,2) : fm(fRow,3)) ];
			end
			times = corrT.t_event{iRow}(idxTr,iMkr);

			% Filter out times
			found = corrT.found{iRow}(idxTr,:);
			time_filter = isfinite(times);
			if evtFilter == '&'
				time_filter = time_filter & found(:,1);
			elseif evtFilter == '1'
				if iMkr == 1
					time_filter = time_filter & found(:,2);
				else
					time_filter(:) = false;
				end
			elseif evtFilter == '2'
				if iMkr == 2
					time_filter = time_filter & found(:,3);
				else
					time_filter(:) = false;
				end
			end
			times = times(time_filter);

			% Write event time data to group structure
			markerData.groups{tRow}(iGrp).times = ...
				[ markerData.groups{tRow}(iGrp).times; times ];
			markerData.groups{tRow}(iGrp).bothEvents = ...
				markerData.groups{tRow}(iGrp).bothEvents + sum(found(:,1));
			markerData.groups{tRow}(iGrp).firstEvent = ...
				markerData.groups{tRow}(iGrp).firstEvent + sum(found(:,2));
			markerData.groups{tRow}(iGrp).secondEvent = ...
				markerData.groups{tRow}(iGrp).secondEvent + sum(found(:,3));
			markerData.groups{tRow}(iGrp).noEvent = ...
				markerData.groups{tRow}(iGrp).noEvent + sum(~any(found, 2));

			% Get largest event time
			thisMaxT = max(times);
			if event_time_max < thisMaxT
				event_time_max = thisMaxT;
			end
		end

	end
end
clear marker tRow times fm fRow idxF idxTr

% Get list of conditions for file name
conditions = unique(fileT.condition(idxConditions));
condition_fn = strjoin(conditions, '-');
if strlength(condition_fn) > 0
	condition_fn = [condition_fn{1} '_'];
else
	condition_fn = '';
end

% Get number of non-empty markers
nMarkers = height(markerData);
if nMarkers == 0
	warning('No cells found; quitting.')
	return
end

%% Initialize figure with axes
fh = figure;
aha = tight_subplot(nMarkers, 1, 0, .1, .1);

%% Plot
for iMkr = 1 : nMarkers
	hold(aha(iMkr), 'on');
	cell_count_max = 0;
	nGroups = numel(markerData.groups{iMkr});

	% Clear variables for allocating the desired class
	clear legend_lbl hha fit_curves fit_curve_max
	legend_lbl(1:nGroups) = "";
	hha(1:nGroups) = matlab.graphics.chart.primitive.Histogram;
	fit_curves(1:nGroups) = matlab.graphics.chart.primitive.Line;
	fit_curve_max = NaN(1, nGroups);

	for iGrp = 1:nGroups
		if isfield(markerData.groups{iMkr}(iGrp), 'legend_index')
			lgdIdx = markerData.groups{iMkr}(iGrp).legend_index;
		else
			lgdIdx = [];
		end

		if isfield(markerData.groups{iMkr}(iGrp), 'color')
			thisColor = markerData.groups{iMkr}(iGrp).color;
		else
			thisColor = lgdT.color(lgdIdx,:);
		end

		% Plot histogram
		hha(iGrp) = histogram(aha(iMkr), markerData.groups{iMkr}(iGrp).times, ...
			0 : event_time_max/n_bins : event_time_max);
		hha(iGrp).EdgeColor = [ 1 1 1 ];
% 		hha(iGrp).EdgeAlpha = 1;
		hha(iGrp).LineWidth = 1;
		hha(iGrp).BinLimits = [0, event_time_max];
		hha(iGrp).FaceColor = thisColor;

		if strcmp(cmpOpt, cmpOpt_none)
			hha(iGrp).FaceAlpha = 1;
		end

		% Add histogram to legend
		if ~isempty(lgdIdx) && isa(lgdT.sample(lgdIdx), ...
				'matlab.graphics.GraphicsPlaceholder')
			lgdT.sample(lgdIdx) = hha(iGrp);
		end

		% Normalize histogram if requested
		if doNormalize
			hha(iGrp).Normalization = 'pdf';
		end

		% Get range for y-axis
		if max(hha(iGrp).Values) > cell_count_max
			cell_count_max = max(hha(iGrp).Values);
		end

		% Create and show lognormal probability distribution
		if any(isfinite(hha(iGrp).Data(:)))
			pdf_x = linspace(hha(iGrp).BinEdges(1), hha(iGrp).BinEdges(end), n_bins * 5);

			[t_max, uncert_tmax, pdf_mkr, pdf_max, mu, sigma] = ...
				hist_dist(hha(iGrp).Data(:), pdf_x, doNormalize);

			% Fit PDF height to histogram
			if ~doNormalize
				pdf_mkr = pdf_mkr * mean(diff(hha(iGrp).BinEdges));
			end

			fit_curve_max(iGrp) = pdf_max;
			markerData.groups{iMkr}(iGrp).t_max = t_max;
			markerData.groups{iMkr}(iGrp).uncert_tmax = uncert_tmax;
			markerData.groups{iMkr}(iGrp).mu = mu;
			markerData.groups{iMkr}(iGrp).sigma = sigma;

			% Plot fit
			if strcmp(cmpOpt, cmpOpt_none)
				fit_color = [0 0 0];
			else
				fit_color = thisColor;
			end
			fit_curves(iGrp) = plot(aha(iMkr), pdf_x, pdf_mkr, '-', ...
				'LineWidth', 1.5, ...
				'Color', fit_color);
% 			plot(aha(iMkr), [t_max t_max], ylim(aha(iMkr)), '-', ...
% 				'LineWidth', 1.5, ...
% 				'Color', fit_color);

			% Write data for legend
			legend_lbl(iGrp) = markerData.groups{iMkr}(iGrp).name;
		else
			warning('No histogram data found for group "%s".', ...
				markerData.groups{iMkr}(iGrp).name);
		end
	end

	% Arrange histograms according to their size
	[~,hist_order] = sort(fit_curve_max, 'descend');
	for iOrd = 1:length(hist_order)
		iGrp = hist_order(iOrd);
		uistack(hha(iGrp), 'top')
		if ~isempty(fit_curves(iGrp).MarkerIndices)
			uistack(fit_curves(iGrp), 'top')
		end
	end

	% Format axes
	x_max = 1.1 * event_time_max;
	y_max = 1.2 * cell_count_max;
	if x_max == 0
		x_max = 1;
	end
	if y_max == 0
		y_max = 1;
	end
	axis(aha(iMkr), [ 0 x_max 0 y_max ]);
	set(aha(iMkr), ...
		'Box', 'on', ...
		'XTickLabelMode', 'auto', ...
		'YTickLabelMode', 'auto', ...
		'XLimMode', 'manual', ...
		'YLimMode', 'manual');

	ylabel(aha(iMkr), y_label_hist);

	% Display conditions above first axis
	if iMkr == 1
		title(aha(iMkr), strjoin(conditions, ', '))
	end

	% Display marker name
	text(aha(iMkr), ...
		0, 1, ...
		[ ' ' markerData.displayName{iMkr} ], ...
		'Units', 'normalized', ...
		'HorizontalAlignment','left', ...
		'VerticalAlignment', 'top');

	% Show xlabels only for lowest axes
	if iMkr == length(aha)
		% Lowest plot
		xlabel(aha(iMkr), x_label_hist);
	else
		% Above lowest plot
		set(aha(iMkr), 'XTickLabels', '');
	end

	% Put axes to top layer
	set(aha(iMkr), 'Layer', 'Top');
end

% Build legend
if ~isempty(lgdT)
	% Initialize legend
	pause(0.2)
	legend(aha(1), lgdT.sample, lgdT.name, ...
		'Location', 'eastoutside');

	% Shrink histogram axes
	pause(0.1)
	wdth_ax = aha(1).Position(3);
	for iAx = 1:numel(aha)
		aha(iAx).Position(3) = wdth_ax;
	end
end

%% If requested, prompt user for desired Ylim
if isFrcYlim
	% Get YLim values of axes
	ylims = zeros(nMarkers, 1);
	for iMkr = 1:nMarkers
		ylims(iMkr) = aha(iMkr).YLim(2);
	end

	% Prompt user for desired YLim values
	answer = inputdlg( ...
			cellstr(strcat(markerData.displayName, ':')), ...
			'Specify axis heights', ...
			1, ...
			cellstr(string(ylims)), ...
			struct('Resize', 'on', 'WindowStyle', 'normal'));

	% Apply user requests
	if ~isempty(answer)
		for iMkr = 1:nMarkers
			newYl = str2double(strrep(answer{iMkr}, ',', '.'));
			if isfinite(newYl) && newYl > 0 && newYl ~= ylims(iMkr)
				aha(iMkr).YLim(2) = newYl;
			end
		end
	end

	% Cleanup
	clear answer newYl ylims
end

%% Save figure
% Only export data if an output directory is given
if ~exist('out_dir', 'var') || ~exist(out_dir, 'dir')
	return
end

% Get time for unique file name
time_now = getTime;

% Get grouping condition for file name
switch cmpOpt
	case cmpOpt_none
		cmpOpt_fn = '';
	case cmpOpt_meas
		cmpOpt_fn = 'byMeasurement_';
	case cmpOpt_comb
		cmpOpt_fn = 'byCombination_';
	case cmpOpt_exp
		cmpOpt_fn = 'byExperiment_';
	otherwise
		cmpOpt_fn = '';
end

% Export figure to file
save_path = fullfile(out_dir, [ time_now '_' ...
	condition_fn cmpOpt_fn 'eventTimeHist.pdf' ]);

% Legends stay well aligned for paper size [15 25] (!?!?!?!?!?)
fh.PaperPositionMode = 'manual';
fh.PaperUnits = 'centimeters';
fh.PaperSize = [18 26];
fh.PaperPosition = [0 0 fh.PaperSize];

print(fh, save_path, '-dpdf')

%% Finally, print information on how many cells were plotted
% Open info file
logfh = fopen(fullfile(out_dir, [ time_now '_' ...
	condition_fn cmpOpt_fn 'eventTimeHist.info' ]), 'w');

% Write data quality statistics
fprintf(logfh, 'Number of cells plotted:\n');
fprintf(logfh, '%-30s %6s %6s %6s %6s %6s\n', 'Marker', 'Both', 'First', 'Second', 'None', 'Total');
fprintf('Number of cells plotted:\n')
fprintf('%-30s %6s %6s %6s %6s %6s\n', 'Marker', 'Both', 'First', 'Second', 'None', 'Total')
for iMkr = 1:nMarkers
	for iGrp = 1:numel(markerData.groups{iMkr})
		mkr = markerData.shortName{iMkr};
		grp = markerData.groups{iMkr}(iGrp).name;
		if strlength(grp) > 0
			mkr = sprintf('%s (%s)', mkr, grp);
		end
		n_both = markerData.groups{iMkr}(iGrp).bothEvents;
		n_first = markerData.groups{iMkr}(iGrp).firstEvent;
		n_second = markerData.groups{iMkr}(iGrp).secondEvent;
		n_none = markerData.groups{iMkr}(iGrp).noEvent;
		n_total = n_both + n_first + n_second + n_none;
		fprintf(logfh, '%-30s %6d %6d %6d %6d %6d\n', ...
			mkr, n_both, n_first, n_second, n_none, n_total);
		fprintf('%-30s %6d %6d %6d %6d %6d\n', ...
			mkr, n_both, n_first, n_second, n_none, n_total)
	end
end

% Write distribution maxima
fprintf(logfh, '\nMaxima of probability distributions:\n');
fprintf(logfh, '%-30s %13s\n', 'Marker', 't(max) [h]');
fprintf('\nMaxima of probability distributions:\n')
fprintf('%-30s %13s\n', 'Marker', 't(max) [h]')
for iMkr = 1:nMarkers
	for iGrp = 1:numel(markerData.groups{iMkr})
		mkr = markerData.shortName{iMkr};
		grp = markerData.groups{iMkr}(iGrp).name;
		if strlength(grp) > 0
			mkr = sprintf('%s (%s)', mkr, grp);
		end
		t_max = markerData.groups{iMkr}(iGrp).t_max;
		uncert = markerData.groups{iMkr}(iGrp).uncert_tmax;
		fprintf(logfh, '%-30s %s\n', mkr, format_sd(t_max, uncert, [6, 6]));
		fprintf('%-30s %s\n', mkr, format_sd(t_max, uncert, [6, 6]));
	end
end

% Close info file
fclose(logfh);

%% Clean-up
clear cell_count_max cm cmpOpt cmpOpt_comb
clear cmpOpt_exp cmpOpt_fn cmpOpt_meas cmpOpt_none condition_fn conditions
clear doNormalize event_time_max evtFilter fh file_idcs fit_color
clear fit_curve_max fit_curves fittedFun found grp hha hist_order
clear iAx iCmb idxConditions idxCorr idxFile idxM idxNoColor iGrp iMap
clear iMeas iMkr iOrd iRow isFrcYlim isOK
clear jMkr legend_lbl legend_obj lgdIdx logfh logN logNormOpt logNormPdf
clear max_idx_pdf meas_sel measurements measurementsUsed mkr mkrMissing
clear mu n_bins n_both n_first n_second n_none n_total nGroups nMarkers
clear pdf_max pdf_mkr pdf_x save_path sigma t_max text_arrow thisColor
clear thisFileT thisIdx thisMaxT thisMeas thisName time_filter time_now
clear uncert uncert_tmax wdth_ax x_label_hist x_max y_label_hist y_max

% end of main part of `plotCorrelation_histograms`
%%

%% Auxiliary function
function [cmpOpt, doNormalize, evtFilter, isFrcYlim] = getPlotOpt( ...
	cmpOpts, doNormalize, evtFilter)
%getPlotOpt assesses plotting options by showing a dialog

	% Get requested preferences
	if nargin < 2 || isempty(doNormalize)
		doNormalize = false;
	end
	if nargin < 3 || isempty(evtFilter)
		evtFilter = '*';
	end

	% Build GUI
	win = figure('Name', 'Histogram settings', ...
		'MenuBar', 'none', ...
		'NumberTitle', 'off', ...
		'CloseRequestFcn', @clsWin, ...
		...'WindowStyle', 'modal', ...
		'Units', 'centimeters');
	win.Position(3:4) = [15 4.5];

	uicontrol(win, ...
		'Style', 'text', ...
		'String', 'Compare different measurements or combinations?', ...
		'HorizontalAlignment', 'left', ...
		'Units', 'normalized', ...
		'Position', [.05 .85 .9 .1]);

	btn_nrmlz = uicontrol(win, ...
		'Style', 'checkbox', ...
		'String', 'Normalize histograms', ...
		'Value', doNormalize, ...
		'Units', 'normalized', ...
		'Position', [.05 .7 .425 .1]);

	btn_frcYlim = uicontrol(win, ...
		'Style', 'checkbox', ...
		'String', 'Set heights manually', ...
		'Value', false, ...
		'Units', 'normalized', ...
		'Position', [.525 .7 .425 .1]);
	
	% Generate radio buttons for event-dependent filtering
	evtFltr_bg = uibuttongroup(win, ...
		'Title', 'Event filter', ...
		'Units', 'normalized', ...
		'Position', [.05 .3 .9 .35]);

	btn_showAll = uicontrol(evtFltr_bg, ...
		'Style', 'radiobutton', ...
		'String', 'Show all cells', ...
		'UserData', '*', ...
		'Units', 'normalized', ...
		'Position', [0, .5, .45, .5]);
	btn_showBoth = uicontrol(evtFltr_bg, ...
		'Style', 'radiobutton', ...
		'String', 'Show only cells with both events', ...
		'UserData', '&', ...
		'Units', 'normalized', ...
		'Position', [0, 0, .45, .5]);
	btn_showFirst = uicontrol(evtFltr_bg, ...
		'Style', 'radiobutton', ...
		'String', 'Show only cells with only first event', ...
		'UserData', '1', ...
		'Units', 'normalized', ...
		'Position', [.45, .5, .55, .5]);
	btn_showSecond = uicontrol(evtFltr_bg, ...
		'Style', 'radiobutton', ...
		'String', 'Show only cells with only second event', ...
		'UserData', '2', ...
		'Units', 'normalized', ...
		'Position', [.45, 0, .55, .5]);

	if evtFilter == '&'
		evtFltr_bg.SelectedObject = btn_showBoth;
	elseif evtFilter == '1'
		evtFltr_bg.SelectedObject = btn_showFirst;
	elseif evtFilter == '2'
		evtFltr_bg.SelectedObject = btn_showSecond;
	else
		evtFltr_bg.SelectedObject = btn_showAll;
	end

	% Generate push buttons for comparison options
	nOpts = numel(cmpOpts);
	btnWdth = ( 1 - (nOpts + 1) * .05 ) / nOpts;
	btnLeft = @(iBtn) .05 + (btnWdth + .05) * (iBtn - 1);
	for iO = 1:numel(cmpOpts)
		uicontrol(win, ...
			'Style', 'pushbutton', ...
			'String', cmpOpts{iO}, ...
			'UserData', cmpOpts{iO}, ...
			'Callback', @clsWin, ...
			'Units', 'normalized', ...
			'Position', [btnLeft(iO) .05 btnWdth .2]);
	end

	% Wait for user to enter requests
	uiwait(win)

	% Window closing callback
	function clsWin(src, ~, ~)
		cmpOpt = src.UserData;
		doNormalize = btn_nrmlz.Value;
		evtFilter = evtFltr_bg.SelectedObject.UserData;
		isFrcYlim = btn_frcYlim.Value;
		delete(win);
	end
end % end of `getPlotOpt`
